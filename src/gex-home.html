<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">

<link rel="import" href="../bower_components/app-layout/app-toolbar/app-toolbar.html">

<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tabs.html">
<link rel="import" href="../bower_components/paper-tabs/paper-tab.html">

<link rel="import" href="../bower_components/chips-api/chips-api.html">

<link rel="import" href="elements/ami-viewer-2d.html">
<link rel="import" href="elements/css-loader.html">
<link rel="import" href="elements/series-preview.html">

<link rel="import" href="import-ami.html">

<link rel="import" href="../bower_components/chips-api/chips-api.html">
<link rel="import" href="../bower_components/chips-api/behaviors/chips-plugin-behavior.html">
<link rel="import" href="../bower_components/control-panel-2d/control-panel-2d.html">

<link rel="import" href="shared-styles.html">
<link rel="import" href="my-icons.html">

<dom-module id="gex-home">
  <template>
    <style include="shared-styles">
      :host {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        background-color: var(--dark-primary-color);
        color: var(--text-primary-color);
        font-weight: lighter;
      }

      .content {
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column;
        background-color: var(--dark-primary-color);
        overflow: hidden;
        position: relative;
      }

      .overlay {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--dark-primary-color);
        z-index: 2;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column;
        -webkit-box-pack: center;
            -ms-flex-pack: center;
                justify-content: center;
        -webkit-box-align: center;
            -ms-flex-align: center;
                align-items: center;
        font-size: 24px;
      }

      .panel {
        width: 192px;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column;
      }

      .viewersC {
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        display:-webkit-box;
        display:-ms-flexbox;
        display:flex;
        -webkit-box-orient: horizontal;
        -webkit-box-direction: normal;
            -ms-flex-direction: row;
                flex-direction: row;
      }

      .viewers {
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        height: 0;
        width: 100%;
      }

      .viewerui {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        height: 100%;
        position: relative;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column;
        width: 0;
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        -webkit-box-sizing: border-box;
                box-sizing: border-box;
        border: 1px solid #212121;
        border-bottom: 4px solid #212121;
      }

      .viewerui.active {
        border-bottom-color: var(--accent-color);
      }

      .series{
        -webkit-box-flex: 1;
            -ms-flex: 1;
                flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .label {
        -webkit-box-flex: 0;
            -ms-flex: 0;
                flex: 0;
        padding: 2px;
        /*min-width: 0;*/
        font-size: 12px;
        color: var(--secondary-text-color);
      }

      .panel.bch {
        border-right: 1px solid var(--divider-color);
      }

      .ge {
        max-height: 192px;
        overflow: hidden;
      }

      .loader {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--dark-primary-color);
        z-index: 2;
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        -webkit-box-align: center;
            -ms-flex-align: center;
                align-items: center;
        -webkit-box-pack: center;
            -ms-flex-pack: center;
                justify-content: center;
        color: #ffffff;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
            -ms-flex-direction: column;
                flex-direction: column;
      }

      paper-slider {
        width: 100%;
        background-color: #000000;
        --paper-slider-container-color: #424242;
        --paper-slider-active-color: #424242;
        --paper-slider-knob-color: var(--accent-color);
        --paper-slider-input: {width: 64px}
      }

      .viewHead {
        width: 100%;
        background-color: var(--dark-primary-color);
      }

      .illustration {
        width: 128px;
        height: 128px;
        margin: auto;
        margin-bottom: 24px;
      }

      .search-image {
        background-image: url("/images/search.svg");
        background-position: center;
        background-size: contain;
        background-repeat: no-repeat;
      }

      .left-image {
        background-image: url("/images/people.svg");
        background-position: center;
        background-size: contain;
        background-repeat: no-repeat;
      }

      .overlay paper-button {
        display: block;
      }

      [hidden] {
        display: none;
      }
    </style>

    <chips-api
      id="API"></chips-api>

    <template is="dom-if" if="[[_isReady(dataStatusBch)]]">
      <div hidden$="[[!visibleBCH]]" class="panel bch">
        <app-toolbar>
          <div main-title>PACS</div>
          <paper-icon-button icon="my-icons:search" on-tap="handleBCH"></paper-icon-button>
          <paper-icon-button icon="my-icons:close" on-tap="hideBCH"></paper-icon-button>
        </app-toolbar>
        <div class="series">
          <!-- Fetching ready -->
          <template is="dom-if" if="[[_isReady(dataStatusBch)]]">
            <template is="dom-repeat" items="[[dataBch]]">
              <series-preview series="[[item]]" on-tap="_handleSeriesSelectedBch"><series-preview>
            </template>
          </template>

        </div>
        <div class="ge" hidden$="[[!_isSelected(dataSelectedBch)]]">
          <app-toolbar>
            <div main-title>Reference</div>
          </app-toolbar>
          <div class="series">
            <template is="dom-repeat" items="[[dataGe]]">
              <series-preview series="[[item]]" on-tap="_handleSeriesSelectedGe"><series-preview>
            </template>
          </div>
        </div>
        <div class="label">
          Copyright (c) 2016 The FNNDSC Project Authors. All rights reserved.</iron-icon>
        </div>
      </div>
      <div hidden$="[[visibleBCH]]" class="bch">
        <paper-icon-button icon="my-icons:chevron-right" on-tap="showBCH"></paper-icon-button>
      </div>

    </template>

    <div class="content">
      <div class="overlay" hidden$="[[_isReady(dataStatusBch)]]">
      <!-- Empty-->
        <template is="dom-if" if="[[_isEmpty(dataStatusBch)]]">
          <paper-button on-tap="handleBCH">
            <div class="search-image illustration">
            </div>
            Find data on the PACS!</paper-button>
        </template>

        <!-- Running plugin -->
        <template is="dom-if" if="[[_isRunning(dataStatusBch)]]">
          <css-loader></css-loader>
          <div>Retrieveing data from the PACS...</div>
        </template>
      </div>
      <div class="overlay" hidden$="[[!_isReadyAndNotSelected(dataStatusBch, dataSelectedBch)]]">
        <div>
          <div class="left-image illustration">
          </div>
          <div>Select DICOM on the left panel.</div>
        </div>
      </div>
      <div class="viewHead">
        <control-panel-2d
          hidden$="[[activeGe]]"
          collapse="{{collapse}}"
          index="{{stackIndexBch}}"
          interpolation="{{stackInterpolationBch}}"
          intensity-auto="{{stackIntensityAutoBch}}"
          intensity-min="[[stackIntensityMinBch]]"
          intensity-max="[[stackIntensityMaxBch]]"
          intensity-range="[[stackIntensityRangeBch]]"
          max-index="[[stackMaxIndexBch]]"
          orientation="{{orientationBch}}"
          window-width="{{stackWindowWidthBch}}"
          window-center="{{stackWindowCenterBch}}"></control-panel-2d>


        <control-panel-2d
          hidden$="[[activeBch]]"
          collapse="{{collapse}}"
          index="{{stackIndexGe}}"
          interpolation="{{stackInterpolationGe}}"
          intensity-auto="{{stackIntensityAutoGe}}"
          intensity-min="[[stackIntensityMinGe]]"
          intensity-max="[[stackIntensityMaxGe]]"
          intensity-range="[[stackIntensityRangeGe]]"
          max-index="[[stackMaxIndexGe]]"
          orientation="{{orientationGe}}"
          window-width="{{stackWindowWidthGe}}"
          window-center="{{stackWindowCenterGe}}"></control-panel-2d>
      </div>

      <div class="viewersC">
        <div class$="[[classIt(activeBch)]]">
          <div hidden$="[[!_isLoading('bch', dataSelectedBch, dataSelectedGe, urlsTotal)]]">
            <div class="loader">
              <div>
                  <!--<paper-spinner active>...</paper-spinner>-->
              </div>
              <div>
                  Loading the data: [[urlsLoaded]] / [[urlsTotal]]
              </div>
            </div>
          </div>
          <paper-slider
            value="{{stackIndexBch}}"
            immediate-value="{{stackIndexBch}}"
            min="0"
            max="[[stackMaxIndexBch]]"
            editable></paper-slider>
          <ami-viewer-2d
            id="render"
            class="viewers"
            active="{{activeBch}}"
            stack-scene="[[stackSceneBch]]"
            stack-index="{{stackIndexBch}}"
            stack-max-index="{{stackMaxIndexBch}}"
            orientation="{{orientationBch}}"
            stack-orientation="{{stackOrientationIndexBch}}"
            stack-window-width="{{stackWindowWidthBch}}"
            stack-window-center="{{stackWindowCenterBch}}"
            intensity-auto="[[stackIntensityAutoBch]]"
            interpolation="[[stackInterpolationBch]]"></ami-viewer-2d>
        </div>
        <div
          class$="[[classIt(activeGe)]]"
          hidden$="[[!_isSelected(dataSelectedGe)]]">
          <div hidden$="[[!_isLoading('ge', dataSelected, dataSelectedGe, urlsTotal)]]">
            <div class="loader">
              <div>
              </div>
              <div>
                  Loading the data: [[urlsLoaded]] / [[urlsTotal]]
              </div>
            </div>
          </div>
          <paper-slider
            value="{{stackIndexGe}}"
            immediate-value="{{stackIndexGe}}"
            min="0"
            max="[[stackMaxIndexGe]]"
            editable></paper-slider>
          <ami-viewer-2d
            id="render2"
            class="viewers"
            active="{{activeGe}}"
            stack-scene="[[stackSceneGe]]"
            stack-index="{{stackIndexGe}}"
            stack-max-index="{{stackMaxIndexGe}}"
            orientation="{{orientationGe}}"
            stack-orientation="{{stackOrientationIndexGe}}"
            stack-window-width="{{stackWindowWidthGe}}"
            stack-window-center="{{stackWindowCenterGe}}"
            intensity-auto="[[stackIntensityAutoGe]]"
            interpolation="[[stackInterpolationGe]]"></ami-viewer-2d>
        </div>
      </div>
    </div>
  </template>

  <script>
    class GEXHome extends CHIPSPluginBehavior(
      Polymer.GestureEventListeners(Polymer.Element)) {
      static get is() {
        return 'gex-home';
      }

      static get properties() {
        return {
          collapse: {
            type: Boolean,
            value: true,
            observer: '_collapseChanged',
          },
          dataBch: {
            type: Array,
            value: [],
            observer: '_dataBchChanged',
          },
          dataStatusBch: {
            type: String,
            value: '',
            observer: '_dataStatusBchChanged',
          },
          dataSelectedBch: {
            type: Object,
            value: {},
            observer: '_dataSelectedBchChanged',
          },
          activeBch: {
            type: Boolean,
            value: true,
            observer: '_activeBchChanged',
          },
          dataGe: {
            type: Array,
            value: [],
            observer: '_dataGeChanged',
          },
          dataStatusGe: {
            type: String,
            value: '',
          },
          dataSelectedGe: {
            type: Object,
            value: {},
            observer: '_dataSelectedGeChanged',
          },
          activeGe: {
            type: Boolean,
            value: false,
            observer: '_activeGeChanged',
          },
          running: {
            type: Boolean,
            value: false,
          },
          visibleGE: {
            type: Boolean,
            value: true,
            observer: '_visibleGeChanged',
          },
          visibleBCH: {
            type: Boolean,
            value: true,
            observer: '_visibleBcgChanged',
          },
          stackHelperBch: {
            type: Object,
            value: {},
            observer: '_stackHelperBchChanged',
          },
          stackSceneBch: {
            type: Object,
            value: {},
          },
          stackHelperGe: {
            type: Object,
            value: {},
            observer: '_stackHelperGeChanged',
          },
          stackSceneGe: {
            type: Object,
            value: {},
          },
          geLink: {
            type: String,
            value: '',
          },
          previousInstance: {
            type: Object,
            value: {},
          },
          stackIndexBch: {
            type: Number,
            value: 0,
            observer: '_stackIndexBchChanged',
          },
          stackMinIndexBch: {
            type: Number,
            value: 0,
          },
          stackMaxIndexBch: {
            type: Number,
            value: 0,
          },
          stackIntensityMinBch: {
            type: Number,
            value: 0,
          },
          stackIntensityMaxBch: {
            type: Number,
            value: 0,
          },
          stackIntensityRangeBch: {
            type: Number,
            value: 0,
          },
          stackWindowWidthBch: {
            type: Number,
            value: 0,
            observer: '_stackWindowWidthBchChanged',
          },
          stackWindowCenterBch: {
            type: Number,
            value: 0,
            observer: '_stackWindowCenterBchChanged',
          },
          stackIntensityAutoBch: {
            type: Boolean,
            observer: '_stackIntensityAutoBchChanged',
          },
          stackInterpolationBch: {
            type: Boolean,
            observer: '_stackInterpolationBchChanged',
          },
          stackIndexGe: {
            type: Number,
            value: 0,
            observer: '_stackIndexGeChanged',
          },
          stackMinIndexGe: {
            type: Number,
            value: 0,
          },
          stackMaxIndexGe: {
            type: Number,
            value: 0,
          },
          stackIntensityMinGe: {
            type: Number,
            value: 0,
          },
          stackIntensityMaxGe: {
            type: Number,
            value: 0,
          },
          stackIntensityRangeGe: {
            type: Number,
            value: 0,
          },
          stackWindowWidthGe: {
            type: Number,
            value: 0,
            observer: '_stackWindowWidthGeChanged',
          },
          stackWindowCenterGe: {
            type: Number,
            value: 0,
            observer: '_stackWindowCenterGeChanged',
          },
          stackIntensityAutoGe: {
            type: Boolean,
            observer: '_stackIntensityAutoGeChanged',
          },
          stackInterpolationGe: {
            type: Boolean,
            observer: '_stackInterpolationGeChanged',
          },
        };
      }

      constructor() {
        super();
        this._resizeListenerBound = this._resizeListener.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        window.addEventListener('resize', this._resizeListenerBound);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener('resize', this._resizeListenerBound);
      }

      handleBCH(event) {
        event.stopPropagation();
        event.preventDefault();
        const openDialog = new CustomEvent(
          'open-dialog',
          {
            detail: {
              open: true,
            },
            bubbles: true,
            composed: true,
          }
        );
        this.dispatchEvent(openDialog);
      }

      handleGE(event) {
        const data = {};
        data.auth = {
          type: 'token',
          token: sessionStorage.getItem('token'),
        };
        //
        data.body = {};
        data.body.template = {};
        // the prefix:
        data.body.template.data = [
          {name: 'prefix', value: ''},
          {name: 'sleep', value: ''},
          {name: 'previous_id', value: ''},
        ];
        data.body.data = {};
        data.body.data['prefix'] = 'ge';
        data.body.data['sleep'] = '10';
        data.body.data['previous_id'] = this.previousInstance.data.id;

        this.$.API.handleAs = 'json';
        const start = this.__startPlugin(this.$.API, this.geLink, data);
        start.then(this._handleRetrieveResponse.bind(this))
          .catch(this._handleRetrieveError.bind(this));
      }

      _handleRetrieveResponse(response) {
        const fetchData = new CustomEvent(
          'start-ge',
          {
            detail: {
              feedLink: this.feedLink,
              pluginInstance: response.data[0],
          },
        });

        // booo :(
        // backend hangs if we do not wait a bit....
        window.setTimeout(
          () => {
            this.dispatchEvent(fetchData);
          }, 1000);
      }

      _handleRetrieveError(error) {
        console.log(error);
      }

      hideBCH() {
        this.visibleBCH = false;
      }

      hideGE() {
        this.visibleGE = false;
      }

      showBCH() {
        this.visibleBCH = true;
      }

      showGE() {
        this.visibleGE = true;
      }

      /**
       * Bch series preview was selected by the user.
       *
       * @param {*} event
       */
      _handleSeriesSelectedBch(event) {
        const targetSeries = event.model.__data.item;
        this._handleSeriesSelected(targetSeries, 'Bch');
      }

      /**
       * Ge series preview was selected by the user.
       *
       * @param {*} event
       */
      _handleSeriesSelectedGe(event) {
        const targetSeries = event.model.__data.item;
        this._handleSeriesSelected(targetSeries, 'Ge');
      }

      /**
       * Series preview was selected by the user.
       *
       * @param {*} targetSeries
       * @param {*} target
       */
      _handleSeriesSelected(targetSeries, target) {
        const selection = this[`dataSelected${target}`];

        // if something was selected before, deselect it.
        if (selection.selected !== undefined) {
          this.set([`data${target}`, ...selection.path, 'selected'], false);
        }

        // select current
        this.set(`dataSelected${target}`, targetSeries);
        this.set([`data${target}`, ...targetSeries.path, 'selected'], true);
      }

      /**
       * Bch selected data changed
       *
       * @param {*} dataSelectedBch
       */
      _dataSelectedBchChanged(dataSelectedBch) {
        if (dataSelectedBch === undefined || !dataSelectedBch.data) {
          return;
        }

        // clean up all stack helpers
        this._resetStackHelper('Bch');
        this._resetStackHelper('Ge');
        // clean up Ge data
        this._resetData('Ge');
        // reset viewers
        this._resizeListener();

        const urls = dataSelectedBch.data.map(function(obj) {
          return `${obj.links.file_resource}`;
        });

        this._urlsSelectedChanged(urls, 'Bch');
      }

      /**
       * Ge selected data changed
       *
       * @param {*} dataSelectedGe
       */
      _dataSelectedGeChanged(dataSelectedGe) {
        if (dataSelectedGe === undefined || !dataSelectedGe.data) {
          return;
        }

        // clean up Ge stack helper
        this._resetStackHelper('Ge');
        // reset viewers
        this._resizeListener();

        const urls = dataSelectedGe.data.map(function(obj) {
          return `${obj.links.file_resource}`;
        });

        this._urlsSelectedChanged(urls, 'Ge');
      }

      _fetchUrl(url) {
        const dataAPI = {};
        dataAPI.auth = {
          type: 'token',
          token: sessionStorage.getItem('token'),
        };
        this.$.API.handleAs = 'arraybuffer';
        return this.$.API.request( 'GET', url, dataAPI );
      }

      _loadUrl(url) {
        const LoadersVolume = AMI.default.Loaders.Volume;
        const loader = new LoadersVolume();

        return this._fetchUrl(url)
          .then((arrayBuffer) => {
            this.urlsLoaded += 1;
            return loader.parse({
              url: url,
              buffer: arrayBuffer,
              })
              .then((response) => {
                this.urlsParsed +=1;
                return response;
              });
          })
          .catch(function(error) {
            window.console.log('oops... something went wrong...');
            window.console.log(error);
          });
      }

      _loadUrls(urls) {
        // number of files to be loaded
        this.urlsTotal = urls.length;
        this.urlsLoaded = 0;
        this.urlsParsed = 0;

        const loadSequences = [];
        urls.forEach((url) => {
          loadSequences.push(
            this._loadUrl(url)
          );
        });
        return Promise.all(loadSequences);
      }

      _urlsSelectedChanged(urls, target) {
        if(urls === undefined ||
          urls.length <= 0) {
          return;
        }

        return this._loadUrls(urls)
          .then((series) => {
            // merge series
            const mergedSeries = series[0].mergeSeries(series);
            const firstSeries = mergedSeries[0];
            return firstSeries;
          })
          .then((series) => {
            // make sure first frame we have is matching the requested url
            // it could be different if a user clicked on
            // different series while another was loading
            const firstFrameUrl = series.stack[0].frame[0].url;
            const dataSelected = this[`dataSelected${target}`];
            const currentSelectionUrls = dataSelected.data.map(function(obj) {
              return `${obj.links.file_resource}`;
            });

            if (currentSelectionUrls.indexOf(firstFrameUrl) < 0) {
              urls = null;
              series = null;
              return;
            }

            // cleanup
            this.urlsTotal = 0;
            this.urlsLoaded = 0;
            this.urlsParsed = 0;

            // new stack Helper
            const localHelper = new AMI.default.Helpers.Stack(series.stack[0]);
            const localScene = new THREE.Scene();
            localScene.add(localHelper);
            this.set(`stackScene${target}`, localScene);
            this.set(`stackHelper${target}`, localHelper);

            // update extra info
            this.$.render.patientID = series.patientID;
            this.$.render.patientAge = series.patientAge;
            this.$.render.patientBorthdate = series.patientBorthdate;
            this.$.render.studyDate = series.studyDate;
            this.$.render.studyDescription = series.studyDescription;
            this.$.render.seriesDescription = series.seriesDescription;

            // activate the view
            this.set(`active${target}`, true);

            // start rendering loop
            this.$.render.startRenderingLoop();
            this.$.render2.startRenderingLoop();

            // resize the viewers
            this._resizeListener();

            // auto fetch GE data
            if (target === 'Bch') {
              this.handleGE();
            }
          })
          .catch((error) => {
            console.log(error);
          });
      }

      _dataStatusBchChanged(status) {
        if (status !== 'ready') {
          this.set('dataBch', []);
          this.set('dataSelectedBch', {});
          this.set('dataGe', []);
          this.set('dataSelectedGe', {});

          // stop rendering loops
          this.$.render.stopRenderingLoop();
          this.$.render2.stopRenderingLoop();
        }
      }

      _visibleGeChanged(visible) {
        this.$.render.resize();
        this.$.render2.resize();
      }

      _visibleBcgChanged(visible) {
        this.$.render.resize();
        this.$.render2.resize();
      }

      _resizeListener() {
        this.$.render.resize();
        this.$.render2.resize();
      }

      _isEmpty(status) {
        return status === 'empty';
      }

      _isRunning(status) {
        return status === 'running';
      }

      _isFetching(status) {
        return status === 'fetching';
      }

      _isReady(status) {
        return status === 'ready';
      }

      _isSelected(data) {
        return !(data === undefined || !data.data);
      }

      _isReadyAndNotSelected(status, data) {
        const ready = this._isReady(status);
        const selected = this._isSelected(data);
        return ready && !selected;
      }

      _activeBchChanged(active) {
        if (active) {
          this.activeGe = false;
        }
      }

      _activeGeChanged(active) {
        if (active) {
          this.activeBch = false;
        }
      }

      _isLoading(target, dataSelectedBch, dataSelectedGe, urlsTotal) {
        // number of files reset to 0 when urls are loaded
        if (target === 'bch' && dataSelectedBch && dataSelectedBch.data &&
          (dataSelectedGe === undefined || dataSelectedGe.data ==undefined) &&
          urlsTotal > 0) {
          return true;
        } else if (
          target === 'ge' &&
          dataSelectedGe &&
          dataSelectedGe.data &&
          urlsTotal > 0) {
          return true;
        }

        return false;
      }

      deselectBch() {
        const selection = this.dataSelectedBch;
        if(selection === undefined || !selection.path) {
          return;
        }

        const path = this.dataSelectedBch.path;
        this.set(['dataBch', ...path, 'selected'], false);
        this.set('dataSelectedBch', {});

        // clean up all stack helpers
        this._resetStackHelper('Bch');
        this._resetStackHelper('Ge');

        // clean up Ge data
        this._resetData('Ge');
      }

      deselectGe() {
        const selection = this.dataSelectedGe;
        if(selection === undefined || !selection.path) {
          return;
        }

        const path = this.dataSelectedGe.path;
        this.set(['dataGe', ...path, 'selected'], false);
        this.set('dataSelectedGe', {});

        //
        this._resetStackHelper('Ge');
      }

      _dataBchChanged(dataBch) {
        if (dataBch === undefined) {
          return;
        }

        this.deselectBch();
      }

      _dataGeChanged(dataGe) {
        if(dataGe === undefined) {
          return;
        }

        this.deselectGe();
      }

      _collapseChanged() {
        this._resizeListener();
      }

      _resetStackHelper(target) {
        // stack
        if (this[`stackHelper${target}`] !== null &&
          this[`stackHelper${target}`]._stack) {
          // reset renderers
          this[`stackScene${target}`].remove(this[`stackHelper${target}`]);
          this.set(`stackScene${target}`, null);
          this[`stackHelper${target}`].dispose();
          this.set(`stackHelper${target}`, null);
        }
      }

      _resetData(target) {
        // data
        this.set(`data${target}`, []);
        this.set(`dataSelected${target}`, {});
        this.set(`dataStatus${target}`, 'empty');
      }

      classIt(active) {
        const baseClass = 'viewerui';
        const activeClass = active ? 'active' : '';

        return `${baseClass} ${activeClass}`;
      }

      /**
       * Stack helper Bch changed
       *
       * @param {*} stackHelper
       */
      _stackHelperBchChanged(stackHelper) {
        this._stackHelperChanged(stackHelper, 'Bch');
      }

      _stackHelperGeChanged(stackHelper) {
        this._stackHelperChanged(stackHelper, 'Ge');
      }

      _stackHelperChanged(stackHelper, target) {
        if (stackHelper === undefined ||
            stackHelper === null ||
            stackHelper.stack === undefined) {
          return;
        }

        // orientation
        this.set(`orientation${target}`, 'default');
        this[`stackHelper${target}`].orientation = 0;

        // more
        this.set(`stackIntensityAuto${target}`, false);
        this._stackIntensityAutoChanged(target, false);

        this.set(`stackInterpolation${target}`, true);
        this._stackInterpolationChanged(target, true);

        // intensity
        // must be last to be set because some flags such as
        // "intensity" can modify it
        const stack = this[`stackHelper${target}`].stack;
        this.set(`stackIntensityMin${target}`, stack.minMax[0]);
        this.set(`stackIntensityMax${target}`, stack.minMax[1]);
        const defaultWW = stack.minMax[1] - stack.minMax[0];
        this.set(`stackIntensityRange${target}`, defaultWW);
        this.set(`stackWindowWidth${target}`, defaultWW);
        this.set(`stackWindowCenter${target}`, stack.minMax[0] + defaultWW / 2);
      }

      /**
       * Stack index Bch changed
       *
       * @param {*} index
       */
      _stackIndexBchChanged(index) {
        this._stackIndexChanged('Bch', index);
      }

      _stackIndexGeChanged(index) {
        this._stackIndexChanged('Ge', index);
      }

      _stackIndexChanged(target, index) {
        const stackHelper = this[`stackHelper${target}`];
        if (index === undefined ||
            stackHelper === undefined ||
            stackHelper === null ||
            stackHelper.stack === undefined) {
          return;
        }

        stackHelper.index = index;

        const auto = this[`stackIntensityAuto${target}`];

        if (auto) {
          const ww = stackHelper.slice.windowWidth;
          this.set(`stackWindowWidth${target}`, ww);

          const wc = stackHelper.slice.windowCenter;
          this.set(`stackWindowCenter${target}`, wc);
        }
      }

      /**
       * Stack window width Bch changed
       *
       * @param {*} windowWidth
       */
      _stackWindowWidthBchChanged(windowWidth) {
        this._stackWindowWidthChanged('Bch', windowWidth);
      }

      _stackWindowWidthGeChanged(windowWidth) {
        this._stackWindowWidthChanged('Ge', windowWidth);
      }

      _stackWindowWidthChanged(target, windowWidth) {
        const stackHelper = this[`stackHelper${target}`];
        if (windowWidth === undefined ||
            stackHelper === undefined ||
            stackHelper === null ||
            stackHelper.stack === undefined) {
          return;
        }

        stackHelper.slice.windowWidth = windowWidth;
      }

      /**
       * Stack window center Bch changed
       *
       * @param {*} windowCenter
       */
      _stackWindowCenterBchChanged(windowCenter) {
        this._stackWindowCenterChanged('Bch', windowCenter);
      }

      _stackWindowCenterGeChanged(windowCenter) {
        this._stackWindowCenterChanged('Ge', windowCenter);
      }

      _stackWindowCenterChanged(target, windowCenter) {
        const stackHelper = this[`stackHelper${target}`];
        if (windowCenter === undefined ||
            stackHelper === undefined ||
            stackHelper === null ||
            stackHelper.stack === undefined) {
          return;
        }

        stackHelper.slice.windowCenter = windowCenter;
      }

      /**
       * Stack intensity auto Bch changed
       *
       * @param {*} auto
       */
      _stackIntensityAutoBchChanged(auto) {
        this._stackIntensityAutoChanged('Bch', auto);
      }

      _stackIntensityAutoGeChanged(auto) {
        this._stackIntensityAutoChanged('Ge', auto);
      }

      _stackIntensityAutoChanged(target, auto) {
        const stackHelper = this[`stackHelper${target}`];
        if (auto === undefined ||
            stackHelper === undefined ||
            stackHelper === null ||
            stackHelper.stack === undefined) {
          return;
        }

        stackHelper.slice.intensityAuto = auto;

        if (auto) {
          const ww = stackHelper.slice.windowWidth;
          this.set(`stackWindowWidth${target}`, ww);

          const wc = stackHelper.slice.windowCenter;
          this.set(`stackWindowCenter${target}`, wc);
        }
      }

      /**
       * Stack interpolation Bch changed
       *
       * @param {*} interpolation
       */
      _stackInterpolationBchChanged(interpolation) {
        this._stackInterpolationChanged('Bch', interpolation);
      }

      _stackInterpolationGeChanged(interpolation) {
        this._stackInterpolationChanged('Ge', interpolation);
      }

      _stackInterpolationChanged(target, interpolation) {
        const stackHelper = this[`stackHelper${target}`];
        if (interpolation === undefined ||
            stackHelper === undefined ||
            stackHelper === null ||
            stackHelper.stack === undefined) {
          return;
        }

        stackHelper.slice.interpolation = interpolation ? 1 : 0;
      }
    }

    window.customElements.define(GEXHome.is, GEXHome);
  </script>
</dom-module>
