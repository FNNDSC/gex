<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">

<link rel="import" href="../bower_components/app-layout/app-toolbar/app-toolbar.html">

<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../bower_components/paper-toggle-button/paper-toggle-button.html">

<link rel="import" href="../bower_components/chips-api/chips-api.html">

<link rel="import" href="elements/ami-viewer-2d.html">
<link rel="import" href="elements/series-preview.html">

<link rel="import" href="import-ami.html">

<link rel="import" href="shared-styles.html">
<link rel="import" href="my-icons.html">

<dom-module id="gex-home">
  <template>
    <style include="shared-styles">
      :host {
        display: flex;
        flex: 1;
        background-color: var(--default-primary-color);
        color: var(--text-primary-color);
        font-weight: lighter;
      }

      .content {
        flex: 1;
        display: flex;
        flex-direction: column;
        background-color: var(--dark-primary-color);
      }

      .panel {
        width: 256px;
        display: flex;
        flex-direction: column;
      }

      .viewers {
        flex: 1;
        display:flex;
        flex-direction: column;
      }

      .viewers > div {
        flex:1;
      }

      .viewers > #bch {
        background-color: var(--bch-light-color);
      }

      .viewers > #ge {
        background-color: var(--ge-light-color);
      }

      /*.bch {
        border-left: 3px solid var(--bch-primary-color);
      }

      .ge {
        border-right: 3px solid var(--ge-primary-color);
      }

      #bch {
        border-top: 1px solid var(--bch-primary-color);
      }

      #ge {
        border-top: 1px solid var(--ge-primary-color);
      }*/

      .series, .controls {
        flex: 1;
        overflow: auto;
      }

      .controls > paper-slider {
        width: 100%;
      }

      /*paper-slider {
        --paper-slider-knob-color: #ccff00;
        --paper-slider-active-color: #ccff00;
      }*/

      [hidden] {
        display: none;
      }
    </style>

    <chips-api
      id="API"></chips-api>

    <div hidden$="[[!visibleBCH]]" class="panel bch">
      <app-toolbar>
        <div main-title>PACS Panel</div>
        <paper-icon-button icon="my-icons:search" on-tap="handleBCH"></paper-icon-button>
        <paper-icon-button icon="my-icons:close" on-tap="hideBCH"></paper-icon-button>
      </app-toolbar>
      <div class="series">

        <template is="dom-if" if="[[running]]">
          Running....
        </template>

        <template is="dom-if" if="[[fetching]]">
          Fetching...
        </template>

        <template is="dom-if" if="[[done]]">
          <!--DATA TO VISUALIZE-->
          <template is="dom-if" if="[[data.length]]">
            <template is="dom-repeat" items="[[data]]">
              <series-preview series="[[item]]" on-tap="_handleSeriesSelected"><series-preview>
            </template>
          </template>
  
          <!--NO DATA TO VISUALIZE-->
          <template is="dom-if" if="[[!data.length]]">
            No data available.
          </template>
        </template>
      </div>
    </div>
    <div hidden$="[[visibleBCH]]" class="bch">
      <paper-icon-button icon="my-icons:chevron-right" on-tap="showBCH"></paper-icon-button>
    </div>

    <div class="content">
      <!--<app-toolbar>
        <div main-title>Viewer actions</div>
      </app-toolbar>-->
      <div class="viewers">
        <ami-viewer-2d id="render" class="viewers" stack-scene="[[stackScene]]"></ami-viewer-2d>
        <!--<div id="bch"></div>-->
        <!--<div id="ge"></div>-->
      </div>
    </div>

    <div hidden$="[[!visibleGE]]" class="panel ge">
      <app-toolbar>
        <div main-title>Control Panel</div>
        <paper-icon-button icon="my-icons:close" on-tap="hideGE"></paper-icon-button>
      </app-toolbar>
      <div class="controls">
        <paper-slider value="{{stackIndex}}" immediate-value="{{stackIndex}}" min="0" max="[[stackMaxIndex]]"></paper-slider>
        <paper-slider value="{{stackWindowWidth}}" immediate-value="{{stackWindowWidth}}" min="1" max="[[stackIntensityRange]]"></paper-slider>
        <paper-slider value="{{stackWindowCenter}}" immediate-value="{{stackWindowCenter}}" min="[[stackIntensityMin]]" max="[[stackIntensityMax]]"></paper-slider>
        <paper-toggle-button checked="{{stackInterpolation}}"></paper-toggle-button>
        <paper-toggle-button checked="{{stackIntensityAuto}}"></paper-toggle-button>
      </div>
    </div>
    <div hidden$="[[visibleGE]]" class="ge">
      <paper-icon-button icon="my-icons:chevron-left" on-tap="showGE"></paper-icon-button>
    </div>
  </template>

  <script>
    class GEXHome extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() { return 'gex-home'; }

      static get properties() {
        return {
          fetching: {
            type: Boolean,
            value: false,
          },
          done: {
            type: Boolean,
            value: false,
          },
          files: {
            type: Array,
            value: [],
            observer: '_filesChanged',
          },
          data: {
            type: Array,
            value: [],
          },
          dataMap: {
            type: Object,
            value: new Map(),
          },
          dataSelected: {
            type: Object,
            value: {},
            observer: '_dataSelectedChanged',
          },
          running: {
            type: Boolean,
            value: false,
          },
          urlsSelected: {
            type: Array,
            value: [],
            observer: '_urlsSelectedChanged',
          },
          visibleGE: {
            type: Boolean,
            value: true,
            observer: '_visibleGEChanged',
          },
          visibleBCH: {
            type: Boolean,
            value: true,
          },
          series: {
            type: Object,
            value: {},
          },
          stackHelper: {
            type: Object,
            value: {},
            observer: '_stackHelperChanged',
          },
          stackScene: {
            type: Object,
            value: {},
          },
          stackIndex: {
            type: Number,
            value: 0,
            observer: '_stackIndexChanged',
          },
          stackMaxIndex: {
            type: Number,
            value: 0,
          },
          stackWindowWidth: {
            type: Number,
            value: 0,
            observer: '_stackWindowWidthChanged',
          },
          stackWindowCenter: {
            type: Number,
            value: 0,
            observer: '_stackWindowCenterChanged',
          },
          stackIntensityRange: {
            type: Number,
            value: 0,
          },
          stackIntensityMin: {
            type: Number,
            value: 0,
          },
          stackIntensityMax: {
            type: Number,
            value: 0,
          },
          stackInterpolation: {
            type: Boolean,
            value: true,
            observer: '_stackInterpolationChanged',
          },
          stackIntensityAuto: {
            type: Boolean,
            value: false,
            observer: '_stackIntensityAutoChanged',
          }
        };
      }

      handleBCH(event) {
        event.stopPropagation();
        event.preventDefault();
        const openDialog = new CustomEvent(
          'open-dialog',
          {
            detail: {
              open: true,
            },
            bubbles: true,
            composed: true,
          }
        );
        this.dispatchEvent(openDialog);
      }

      handleGE(event) {
        console.log('fetch GE data');
      }

      hideBCH() {
        this.visibleBCH = false;
      }

      hideGE() {
        this.visibleGE = false;
      }

      showBCH() {
        this.visibleBCH = true;
      }

      showGE() {
        this.visibleGE = true;
      }

      _seriesStructure() {
        return {
          data: [],
          preview: null,
          details: {
            series: {
              date: 'no value provided',
              description: 'no value provided',
              files: 0,
            },
          },
        }
      }

      _filesChanged(files) {
        if(files === undefined) {
          return;
        }

        // clear the map
        this.dataMap.clear();

        for (const file of files) {
          // handle DCM files
          if (file.data.fname.endsWith('.dcm')) {
            this._handleDCM(file);
          } else if (file.data.fname.endsWith('preview.jpg')) {
            this._handleJPG(file);
          }
        }

        // convert data map to array for polymer dom-repeat to kick in
        this._updateDataArray();

        // fetch previews
        // we need to do it after _updateDataArray
        // so "path" is set in the series
        for(const series of this.data) {
          if (series.preview !== null) {
            this._fetchPreview(series);
          }
        }
      }

      _handleDCM(file) {
        const series = this._getSeriesFromFile(file);
        series.data.push(file);
      }

      _handleJPG(file) {
        const series = this._getSeriesFromFile(file);
        series.preview = file;
      }

      _getSeriesFromFile(file) {
        // get series directory
        const relativeFname = file.data.relative_fname;
        const relativeDirectory =
          relativeFname.slice(0, relativeFname.lastIndexOf('/'));
        
        // find series in the map
        let series = this.dataMap.get(relativeDirectory);
        if (series === null || series === undefined) {
          // add new series  in the map if not present
          series = this._seriesStructure();
          this.dataMap.set(relativeDirectory, series);
        }
        return series;
      }

      _fetchPreview(series) {
        //
        const apiData = {};
        apiData.auth = {
          type: 'token',
          token: sessionStorage.getItem('token'),
        };
        apiData.params = {};
        // fetch ressource then update it all...
        this.$.API.handleAs = 'blob';
        this.$.API.request('GET', series.preview.links.file_resource, apiData)
        .then((response) => {
          this.set(['data', ...series.path, 'preview.blob'], response);
        })
        .catch((error) => {
          console.log(error);
        });
      }

      _updateDataArray() {
        // Map to array
        const dataArray = [];
        // update map data
        function logMapElements(value, key) {
            // set study series description
            let seriesDate = 'no value provided';
            let seriesDescription = 'no value provided';
            const fullName = value.data[0].data.fname;
            const splitName = fullName.split('/');
            if (splitName.length >= 2) {
              const directory = splitName[splitName.length - 2];
              const splitSeries = directory.split('-');
              if (splitSeries.length === 3) {
                seriesDescription = splitSeries[0];
                seriesDate = splitSeries[1];
                if (seriesDate.length === 8) {
                  seriesDate = `
                    ${seriesDate.substring(0, 4)}-
                    ${seriesDate.substring(4, 6)}-
                    ${seriesDate.substring(6, 8)}`;
                }
              }
            }
            value.details.series.date = seriesDate;
            value.details.series.description = seriesDescription;
            // set study date
            // set files
            value.details.series.files = value.data.length + ' file';
            if (value.data.length > 1) {
              value.details.series.files += 's';
            }
            //
            value.selected = false;
            value.path = [];
            value.path.push(dataArray.length);
            dataArray.push(value);
        }
        
        this.dataMap.forEach(logMapElements);
        // update data
        this.set('data', dataArray);
      }

      _handleSeriesSelected(event) {
        // unselect previous if any
        if (this.dataSelected.selected !== undefined) {
          this.set(['data', ...this.dataSelected.path, 'selected'], false);
        }
        // select current
        const targetSeries = event.model.__data.item;
        this.set('dataSelected', targetSeries);
        this.set(['data', ...targetSeries.path, 'selected'], true);
      }

      _dataSelectedChanged(dataSelected) {
        if (dataSelected === undefined || !dataSelected.data) {
          return;
        }
        const urlsSelected = dataSelected.data.map(function(obj) {
          return `${obj.links.file_resource}`;
        });
        this.set('urlsSelected', urlsSelected);
      }

      _urlsSelectedChanged(urls) {
        if(urls === undefined ||
        urls.length <= 0) {
          return;
        }

        // need to fetch with "chips api" to pass token properly
        const LoadersVolume = AMI.default.Loaders.Volume;
        const loader = new LoadersVolume();

        const dataAPI = {};
        dataAPI.auth = {
          type: 'token',
          token: sessionStorage.getItem('token')
        };

        const fetch = (url) => {
          this.$.API.handleAs = 'arraybuffer';
          return this.$.API.request( 'GET', url, dataAPI );
        }

        // default load sequence promise
        const loadSequence = (url) => {
          return fetch(url)
            .then((rawData) => {
              return loader.parse({
                url: url,
                buffer: rawData,
                });
            })
            .catch(function(error) {
              window.console.log('oops... something went wrong...');
              window.console.log(error);
            });
        }

        const load = (url) => {
          // if we load a single file, convert it to an array
          if (!Array.isArray(url)) {
            url = [url];
          }
          const loadSequences = [];
          url.forEach((file) => {
            loadSequences.push(
              loadSequence(file)
            );
          });
          return Promise.all(loadSequences);
        }

        return load(urls)
          .then((series) => {
            // merge series
            const mergedSeries = series[0].mergeSeries(series);
            const firstSeries = mergedSeries[0];
            console.log(firstSeries);
            return firstSeries;
          })
          .then((series) => {
            this.set('series', series);
            
            // cleanup
            if (this.stackHelper !== null &&
              this.stackHelper._stack) {
              this.stackScene.remove(this.stackHelper);
              this.stackHelper.dispose();
              this.stackHelper = null;
            }

            // new stack Helper
            console.log('create stack Helper');
            const stackHelper = new AMI.default.Helpers.Stack(series.stack[0]);
            this.set('stackHelper', stackHelper);
            const stackScene = new THREE.Scene();
            stackScene.add(this.stackHelper);
            this.set('stackScene', stackScene)
          })
          .catch((error) => {
            console.log(error);
          });
      }

      _stackHelperChanged(stackHelper) {
        if (stackHelper === undefined ||
            stackHelper === null ||
           !stackHelper._stack) {
          return;
        }

        console.log(stackHelper);
       
        // acquisition direction by default
        const stack = stackHelper.stack;

        // orientation
        stackHelper.orientation = 0;

        // index
        
        const index = stackHelper.index;
        this.stackMaxIndex = stackHelper.orientationMaxIndex;
        this.stackIndex = index;
        

        // intensity
        this.stackIntensityMin = stack.minMax[0];
        this.stackIntensityMax = stack.minMax[1];
        this.stackIntensityRange = stack.minMax[1] - stack.minMax[0];
        this.stackWindowWidth = this.stackIntensityRange;
        this.stackWindowCenter = stack.minMax[0] + this.stackIntensityRange / 2;
        
        // extra
        this.stackInterpolation = true;
        this.set('stackHelper.slice.interpolation', this.stackInterpolation ? 1 : 0);
        this.stackIntensityAuto = false;
        this.set('stackHelper.slice.intensityAuto', this.stackIntensityAuto );

      }

      _stackIndexChanged(index) {
        this.set('stackHelper.index', index);

        if (this.stackIntensityAuto) {
          this.stackWindowWidth = this.stackHelper.slice.windowWidth;
          this.stackWindowCenter = this.stackHelper.slice.windowCenter;
        }
      }

      _stackWindowWidthChanged(width) {
        this.set('stackHelper.slice.windowWidth', width);
      }

      _stackWindowCenterChanged(center) {
        this.set('stackHelper.slice.windowCenter', center);
      }

      _stackInterpolationChanged(interpolation) {
        this.set('stackHelper.slice.interpolation', interpolation ? 1 : 0);
      }

      _stackIntensityAutoChanged(auto) {
        this.set('stackHelper.slice.intensityAuto', auto);

        if (auto) {
          this.stackWindowWidth = this.stackHelper.slice.windowWidth;
          this.stackWindowCenter = this.stackHelper.slice.windowCenter;
        }
      }

      _visibleGEChanged(visible) {
        this.$.render.resize()
      }
      
    }

    window.customElements.define(GEXHome.is, GEXHome);
  </script>
</dom-module>
