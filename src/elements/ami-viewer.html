<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">

<!-- Paper components  -->
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../bower_components/paper-menu-button/paper-menu-button.html">
<link rel="import" href="../../bower_components/paper-slider/paper-slider.html">

<!-- Iron components  -->
<link href="../../bower_components/iron-icons/iron-icons.html" rel="import">
<link href="../../bower_components/iron-icons/av-icons.html" rel="import">

<!-- CHIPS components -->
<link rel="import" href="../../bower_components/chips-api/chips-api.html">

<!-- Local components -->
<link rel="import" href="../import-ami.html">
<link rel="import" href="./ami-renderer.html">

<dom-module id="ami-viewer">
  <template>

    <style>
      :host {
        display: block;
      }

      .container {
        height: 100%;
        width: 100%;
        display:flex;
      }

      .container > div {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--dark-primary-color);
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ffffff;
        overflow: hidden;
      }

      .renderer-container {
        flex-direction: column;
        margin: 2px;
      }

      .toolbar {
        width: 100%;
        display: flex !important;
        /* position: absolute;
        top: 0;
        background: rgba(0, 0, 0, .7); */
        width: 100%;
        display: flex !important;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--default-primary-color);
        z-index: 2;
      }

      .shortcut {
        position: absolute;
        top: 0;
        right: 0;
        z-index: 2;
        background-color: rgba(0, 0, 0, .7);
        border-radius: 50%;
      }

      paper-icon-button {
        background-color: var(--dark-primary-color);
      }

      .renderer {
        flex: 1;
        width: 100%;
        background-color: darkgray;
        position: relative;
      }

      ami-renderer {
        position: absolute;
        top:0;
        bottom: 0;
        left: 0;
        right: 0;
      }

      .overlay {
        z-index: 2;
      }

      .overlay.drag {
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 3;
      }

      .drag > div {
        padding: 45px;
        border: 5px dashed var(--accent-color);
      }

      paper-slider {
        flex: 1;
        background-color: var(--dark-primary-color);
        --paper-slider-container-color: #424242;
        --paper-slider-activate-color: #424242;
        --paper-slider-knob-color: var(--accent-color);
        margin: 0;
      }

      paper-menu-button {
        padding: 0;
      }

      .iron-selected {
        color: var(--accent-color);
      }

      [hidden] {
        display: none !important;
      }

    </style>

    <chips-api id="API"></chips-api>

    <div class="container" on-mouseenter="_showControls" on-mouseleave="_hideControls">
      <div hidden$=[[!empty]] class="overlay"> &lt; empty /&gt; </div>
      <div hidden$=[[!drag]] class="overlay drag">
        <div> Drop data! </div>
      </div>
      <div hidden$=[[!loading]] class="overlay"> Loading images ([[imagesLoaded]]/[[imagesTotal]]) </div>
      <div hidden$=[[!loaded]] class="renderer-container"> 
        <div class="renderer">
          <ami-renderer
            id="renderer"
            activate="{{activate}}"
            annotations="[[annotations]]"
            cursor="{{cursor}}"
            orientation="[[orientation]]"
            color-lut="{{colorLut}}"
            stack-scene="[[stackScene]]"
            localizer-scene="[[localizerScene]]"
            stack-index="{{index}}"
            stack-max-index="{{indexMax}}"
            window-center="{{windowCenter}}"
            window-level="{{windowLevel}}"
            window-width="{{windowWidth}}"></ami-renderer>
        </div>
        <paper-icon-button hidden$="{{!linked}}" class$="shortcut {{_isLinked(linked)}}" icon="icons:link" on-tap="_toggleLinked"></paper-icon-button>                                
        <div hidden$="{{!showControls}}" class="toolbar" on-tap="_activateViewer">
            <paper-icon-button icon$="{{_playIcon(play)}}" on-tap="_togglePlay"></paper-icon-button>
            <paper-slider
              value="{{index}}"
              immediate-value="{{index}}"
              snaps
              min="[[indexMin]]"
              max="[[indexMax]]"></paper-slider>
  
            <paper-menu-button vertical-align="bottom">
              <paper-icon-button icon="av:subtitles" slot="dropdown-trigger" alt="menu"></paper-icon-button>
              <paper-listbox slot="dropdown-content" selected="{{annotations}}">
                <paper-item>none</paper-item>
                <paper-item>basic</paper-item>
                <paper-item>full</paper-item>
              </paper-listbox>
            </paper-menu-button>
            <paper-icon-button class$="{{_isLinked(linked)}}" icon="icons:link" on-tap="_toggleLinked"></paper-icon-button>                        
            <paper-icon-button icon$="{{_fullscreenIcon(fullscreen)}}" on-tap="_toggleFullscren"></paper-icon-button>
            <paper-icon-button icon="icons:clear" on-tap="_clear"></paper-icon-button>            
          </div>
      </div>
    </div>

  </template>

  <script>
    class AmiViewer extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() {
        return 'ami-viewer';
      }

      static get properties() {
        return {
          empty: {
            type: Boolean,
            value: false,
            observer: '_emptyChanged',
          },
          drag: {
            type: Boolean,
            value: false,
            observer: '_dragChanged',
          },
          loading: {
            type: Boolean,
            value: false,
            observer: '_loadingChanged',
          },
          loaded: {
            type: Boolean,
            value: false,
            observer: '_loadedChanged',
          },
          activate: {
            type: Boolean,
            value: false,
            observer: '_activateChanged',
          },
          fullscreen: {
            type: Boolean,
            value: false,
            observer: '_fullscreenChanged',
          },
          play: {
            type: Boolean,
            value: false,
          },
          annotations: {
            type: Number,
            value: 2,
          },
          orientation: {
            type: String,
            value: 'default',
            observer: '_orientationChanged',
          },
          colorLut: {
            type: String,
          },
          index: {
            type: Number,
            value: 0,
            observer: '_indexChanged',
          },
          indexMin: {
            type: Number,
            value: 0,
          },
          indexMax: {
            type: Number,
            value: 0,
          },
          images: {
            type: Array,
            value: [],
            observer: '_imagesChanged',
          },
          indexSync: {
            type: Number,
            value: 0,
            notify: true,
            observer: '_indexSyncChanged',
          },
          linked: {
            type: Boolean,
            value: false,
          },
          imagesTotal: {
            type: Number,
          },
          imagesLoaded: {
            type: Number,
          },
          imagesParsed: {
            type: Number,
          },
          stackScene: {
            type: Object,
          },
          stackHelper: {
            type: Object,
          },
          windowCenter: {
            type: Number,
            notify: true,
          },
          windowLevel: {
            type: String,
            notify: true,
            observer: '_windowLevelChanged',
          },
          windowWidth: {
            type: Number,
            notify: true,
          },
          cursor: {
            type: Object,
            value: {
              x: 0,
              y: 0,
              z: 0,
            },
            notify: true,
            observer: '_cursorChanged',
          },
          minMax: {
            type: Array,
            notify: true,
          },
          histogram: {
            type: Array,
            notify: true,
          },
          localizer: {
            type: Object,
            notify: true,
          },
          localizer0: {
            type: Object,
            notify: true,
            observer: '_localizerChanged',
          },
          localizer1: {
            type: Object,
            notify: true,
            observer: '_localizerChanged',
          },
          localizer2: {
            type: Object,
            notify: true,
            observer: '_localizerChanged',
          },
          showControls: {
            type: Boolean,
            value: false,
          },
        };
      }

      constructor() {
        super();
      }

      _emptyChanged(empty) {

      }

      _dragChanged(drag) {

      }

      _loadingChanged(loading) {

      }

      _loadedChanged(loaded) {

      }

      _fullscreenChanged(fullscreen) {

      }

      _fullscreenIcon(fullscreen) {
        return fullscreen ? 'icons:fullscreen-exit' : 'icons:fullscreen';
      }

      _toggleFullscren() {
        if (!this.fullscreen) {
          this._enterFullscreen();
        } else {
          this._exitFullscreen();
        }

        this.fullscreen = !this.fullscreen;
        // ami/threejs?
        // clear ami-renderer
      }

      _enterFullscreen() {
        const enterFullscreen = new CustomEvent(
          'enter-fullscreen',
          {
            detail: {},
          }
        );

        this.dispatchEvent(enterFullscreen);
      }

      _exitFullscreen() {
        const exitFullscreen = new CustomEvent(
          'exit-fullscreen',
          {
            detail: {},
          }
        );

        this.dispatchEvent(exitFullscreen);
      }

      _playIcon(play) {
        return play ? 'av:pause' : 'av:play-arrow';
      }

      _togglePlay() {
        if (!this.play) {
          this._startPlay();
        } else {
          this._stopPlay();
        }

        this.play = !this.play;
      }

      _startPlay() {
        this.playInterval = setInterval(() => {
          this.index = (this.index + 1) % this.indexMax;
        }, 300);
      }

      _stopPlay() {
        clearInterval(this.playInterval);
      }

      _activateViewer() {
        this.activate = true;
      }

      _activateChanged(activate) {
        if (activate) {
          const activateRenderer = new CustomEvent(
            'activate',
            {
              detail: {},
            }
          );

          this.dispatchEvent(activateRenderer);
          this.activate = false;
        }
      }

      _clear(event) {
        event.preventDefault();
        event.stopPropagation();

        this.images = [];

        const deactivate = new CustomEvent(
          'deactivate',
          {}
        );

        this.dispatchEvent(deactivate);

        this.$.renderer.stopRenderingLoop();

        // cleanup localizer
        // notify the other renderers
        this.localizer = new THREE.Vector4();
        // free memory
        this.localizerScene.remove(this.localizerHelper);
        this.localizerScene = null;
        // this.localizerHelper.dispose();
        this.localizerHelper = null;

        // cleanup stack
        this.stackScene.remove(this.stackHelper);
        this.stackScene = null;
        this.stackHelper.dispose();
        this.stackHelper = null;
      }

      _imagesChanged() {
        if(this.images.length === 0) {
          this.empty = true;
          this.drag = false;
          this.loaded = false;
          this.loading = false;
          return;
        }

        this.loading = true;

        // start loading the data!
        return this._loadUrls(this.images)
          .then((series) => {
            // merge series
            const mergedSeries = series[0].mergeSeries(series);
            const firstSeries = mergedSeries[0];
            return firstSeries;
          })
          .then((series) => {
            this.empty = false;
            this.loading = false;
            this.loaded = true;

            // init the stack helper
            const stack = series.stack[0];
            const helper = new AMI.default.Helpers.Stack(stack);
            const scene = new THREE.Scene();
            scene.add(helper);
            this.stackScene = scene;
            this.stackHelper = helper;
            this.stackHelper.bbox.visible = false;
            this.stackHelper.border.visible = false;
            this.stackHelper.slice.intensityAuto = false;

            // init the localizer
            this.localizer = helper.slice.cartesianEquation();
            this.localizerHelper = new AMI.default.Helpers.Localizer(
              stack,
              this.stackHelper.slice.geometry,
              this.localizer);
            this.localizerHelper.plane1 = new THREE.Vector4();
            this.localizerHelper.plane2 = new THREE.Vector4();
            this.localizerHelper.plane3 = new THREE.Vector4();
            this.localizerHelper.color1 = new THREE.Vector3();
            this.localizerHelper.color2 = new THREE.Vector3();
            this.localizerHelper.color3 = new THREE.Vector3();

            const localizerScene = new THREE.Scene();
            localizerScene.add(this.localizerHelper);
            this.localizerScene = localizerScene;

            this.windowCenter = this.stackHelper.stack.windowCenter;
            this.windowWidth = this.stackHelper.stack.windowWidth;
            this.minMax = this.stackHelper.stack.minMax;

            const histogram = new Array(1 + this.minMax[1] - this.minMax[0]);
            const slope = this.stackHelper.stack.rescaleSlope;
            const intercept = this.stackHelper.stack.rescaleIntercept;
            for (let i = 0; i < this.stackHelper.stack.frame.length; i++) {
              const frame = this.stackHelper.stack.frame[i];
              for (let j = 0; j < frame.pixelData.length; j++) {
                const value = AMI.default.Core.Utils.rescaleSlopeIntercept(
                  frame.pixelData[j],
                  slope,
                  intercept)
                ;
                if (histogram[value] === undefined) {
                  histogram[value] = 0;
                }
                histogram[value] += 1;
              }
            }

            this.set('histogram', histogram);

            // resize the renderer as it was initialized offscreen
            this.$.renderer.resize();

            // start rendering loop
            this.$.renderer.startRenderingLoop();

            // update series information
            this.$.renderer.patientID = series.patientID;
            this.$.renderer.patientName = series.patientName;
            this.$.renderer.patientAge = series.patientAge;
            this.$.renderer.patientBorthdate = series.patientBorthdate;
            this.$.renderer.studyDate = series.studyDate;
            this.$.renderer.studyDescription = series.studyDescription;
            this.$.renderer.seriesDescription = series.seriesDescription;

            // activate the element
            this._activateChanged(true);
          });
      }

      _windowLevelChanged() {
        if (this.windowLevel === 'Default' && this.stackHelper) {
          this.windowCenter = this.stackHelper.stack.windowCenter;
          this.windowWidth = this.stackHelper.stack.windowWidth;
        }
      }

      _fetchUrl(url) {
        const dataAPI = {};
        dataAPI.auth = {
          type: 'token',
          token: sessionStorage.getItem('token'),
        };
        this.$.API.handleAs = 'arraybuffer';
        return this.$.API.request( 'GET', url, dataAPI );
      }

      _loadUrl(url) {
        const LoadersVolume = AMI.default.Loaders.Volume;
        const loader = new LoadersVolume();

        return fetch(url)
          .then((response) => response.arrayBuffer())
          .then((arrayBuffer) => {
            this.imagesLoaded += 1;
            return loader.parse({
              url: url,
              buffer: arrayBuffer,
              })
              .then((response) => {
                this.imagesParsed +=1;
                return response;
              });
          })
          .catch(function(error) {
            window.console.log('oops... something went wrong...');
            window.console.log(error);
          });
      }

      _loadUrls(urls) {
        // number of files to be loaded
        this.imagesTotal = urls.length;
        this.imagesLoaded = 0;
        this.imagesParsed = 0;

        const loadSequences = [];
        urls.forEach((url) => {
          loadSequences.push(
            this._loadUrl(url)
          );
        });
        return Promise.all(loadSequences);
      }

      resize() {
        this.$.renderer.resize();
      }

      _cursorChanged(cursor) {
      }

      _localizerChanged() {
        if (this.localizerHelper === undefined ||
          this.localizerHelper === null) {
          return;
        }

        const referenceNormal = new THREE.Vector3(
          this.localizerHelper.referencePlane.x,
          this.localizerHelper.referencePlane.y,
          this.localizerHelper.referencePlane.z
        );

        if (this.localizer0 !== undefined && this.localizer0 !== null) {
          // also make sure it is not parallel to reference place
          const l0Normal = new THREE.Vector3(
            this.localizer0.x,
            this.localizer0.y,
            this.localizer0.z
          );
          l0Normal.cross(referenceNormal);

          if (l0Normal.length() > 0.01) {
            this.localizerHelper.plane1 = this.localizer0;
            this.localizerHelper.color1 = new THREE.Color(0x00ff00);
          } else {
            this.localizerHelper.plane1 = l0Normal;
          }
        }

        if (this.localizer1 !== undefined && this.localizer1 !== null) {
          // also make sure it is not parallel to reference place
          const l1Normal = new THREE.Vector3(
            this.localizer1.x,
            this.localizer1.y,
            this.localizer1.z
          );
          l1Normal.cross(referenceNormal);

          if (l1Normal.length() > 0.01) {
            console.log(this.localizer1);
            this.localizerHelper.plane2 = this.localizer1;
            this.localizerHelper.color2 = new THREE.Color(0x00ff00);
          } else {
            this.localizerHelper.plane2 = l1Normal;
          }
        }

        if (this.localizer2 !== undefined && this.localizer2 !== null) {
          // also make sure it is not parallel to reference place
          const l2Normal = new THREE.Vector3(
            this.localizer2.x,
            this.localizer2.y,
            this.localizer2.z
          );
          l2Normal.cross(referenceNormal);

          if (l2Normal.length() > 0.01) {
            this.localizerHelper.plane3 = this.localizer2;
            this.localizerHelper.color3 = new THREE.Color(0x00ff00);
          } else {
            this.localizerHelper.plane3 = l2Normal;
          }
        }
        this.$.renderer.resize();
      }

      _orientationChanged() {
        this._updateLocalizer();
        this._localizerChanged();
      }

      _indexChanged() {
        this._updateLocalizer();

        // if sync'ed, update value: this.indexSync = this.index;
        if (this.linked) {
          this.indexSync = this.index;
        }
      }

      _updateLocalizer() {
        if (
          this.stackHelper === undefined ||
          this.stackHelper === null) {
          return;
        }

        // update localizer helper
        this.localizerHelper.referencePlane =
          this.stackHelper.slice.cartesianEquation();
        this.localizerHelper.geometry = this.stackHelper.slice.geometry;

        // notify other renderer of new plane position
        this.localizer = this.localizerHelper.referencePlane;
        this.$.renderer.resize();
      }

      _indexSyncChanged(indexSync) {
       // if synced, update index this.index = indexSunc;
       if (this.linked) {
          this.index = indexSync;
        }
      }

      _toggleLinked() {
        this.linked = !this.linked;
      }

      _isLinked(linked) {
        return linked ? 'iron-selected' : '';
      }

      _showControls() {
        this.showControls = true;
        // setTimeout(() => {
        //   this.showControls = false;
        //   }, 3000);
      }

      _hideControls() {
        this.showControls = false;
      }
    }
    window.customElements.define(AmiViewer.is, AmiViewer);
  </script>
</dom-module>

<!-- TODO: play skips last index -->
<!-- TODO: window level should -->
