<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<link rel="import" href="../import-ami.html">

<dom-module id="ami-viewer-2d">
  <template>

    <style>
      :host {
        display: block;
        position: relative;
      }

      #container {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #orientation {
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        position: absolute;
        width: 100%;
        height: 100%;
        overflow:hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;

      }

      .direction {
        z-index: 1;
        color: #fff;
        text-transform: uppercase;
        font-size: 16px;
        position: absolute;
        margin: 14px;
        padding: 4px;
        text-align: center;
        background-color: rgba(0, 0, 0, .3);
      }

      #top {
        top: 24px;
      }

      #bottom {
        bottom: 0;
      }

      #left {
        left: 0;
      }

      #right {
        right: 0;
      }

    </style>

    <div id="orientation">
      <div id="top" class="direction"></div>
      <div id="bottom" class="direction"></div>
      <div id="left" class="direction"></div>
      <div id="right" class="direction"></div>
    </div>

    <div id="container">
    </div>

    </template>

  <script>
    class AMIViewer2D extends Polymer.Element {
      static get is() {
        return 'ami-viewer-2d';
      }
      static get properties() {
        return {
          animationFrameID: {
            type: Number,
            value: -1,
          },
          stackHelper: {
            type: Object,
            value: {},
          },
          stackScene: {
            type: Object,
            value: {},
            observer: '_stackSceneChanged',
          },
          orientation: {
            type: String,
            value: 'default',
            observer: '_orientationChanged',
          }
        };
      }

      ready() {
        super.ready();
        this._initViewer();
      }

      _initViewer() {
        this._container = this.$.container;
        this._slice = null;
        this._scene = null;
        this._clipPlane = null;
        this._stackHelper = null;
        this.orientation = 'default';

        this._initScene();
        this._initCamera();
        this._initControls();
        this._initRenderer();

        // add dummy cube for testing
        const geometry = new THREE.BoxGeometry(200, 200, 200);
        const material = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true
        });
        this._mesh = new THREE.Mesh(geometry, material);
        this._scene.add(this._mesh);

        this._animate();
      }

      _initScene() {
        this._scene = new THREE.Scene();
      }

      _initCamera() {
        this._camera = new AMI.default.Cameras.Orthographic(
          this._container.clientWidth / -2,
          this._container.clientWidth / 2,
          this._container.clientHeight / -2,
          this._container.clientHeight / 2,
          1, 1000 );
      }

      _initControls() {
        this._controls =
          new AMI.default.Controls.TrackballOrtho(this._camera, this._container);
        this._controls.staticMoving = true;
        this._controls.noRotate = true;
        this._controls.target.set(0, 0, 0);
        this._camera.controls = this._controls;
      }

      _initRenderer() {
        this._renderer = new THREE.WebGLRenderer({
          antialias: true,
        });
        this._renderer.autoClear = false;
        this._renderer.localClippingEnabled = true;
        this._renderer.setSize(
        this._container.clientWidth, this._container.clientHeight);
        this._container.appendChild( this._renderer.domElement );
      }

      _animate() {
        this.animationFrameID = requestAnimationFrame(() => {this._animate()} );
        this._controls.update();
        this._renderer.clear();

        this._mesh.rotation.x += 0.01;
        this._mesh.rotation.y += 0.02;
        this._renderer.render( this._scene, this._camera );
      }

      _stackSceneChanged(stackScene) {
        if (stackScene === undefined || !stackScene.children) {
          return;
        }

        this._scene = stackScene;
        this.update();
      }

      update() {
        const stackHelper = this._scene.children[0];
        if (stackHelper) {
          this._stackHelper = stackHelper;
          const stack = stackHelper.stack;
          stackHelper.slice.canvasWidth = this._container.clientWidth;
          stackHelper.slice.canvasHeight = this._container.clientHeight;

          // set camera
          const worldbb = stack.worldBoundingBox();
          const lpsDims = new THREE.Vector3(
            (worldbb[1] - worldbb[0])/2,
            (worldbb[3] - worldbb[2])/2,
            (worldbb[5] - worldbb[4])/2
          );

          // box: {halfDimensions, center}
          const box = {
            center: stack.worldCenter().clone(),
            halfDimensions:
              new THREE.Vector3(lpsDims.x + 10, lpsDims.y + 10, lpsDims.z + 10),
          };

          // init and zoom
          const canvas = {
              width: this._container.clientWidth,
              height: this._container.clientHeight,
            };

          this._camera.directions =
            [stack.xCosine, stack.yCosine, stack.zCosine];
          this._camera.box = box;
          this._camera.canvas = canvas;
          this._camera.orientation = this.orientation;
          this._camera.update();
          this._camera.fitBox(2, 1);

          stackHelper.orientation = this._camera.stackOrientation;
          stackHelper.index = Math.floor(stackHelper.orientationMaxIndex/2);

          this.updateLabels(this._camera.directionsLabel, this._stackHelper.stack.modality);
        }
      }

      resize() {
        if (this._stackHelper) {
          const canvas = {
            width: this._container.clientWidth,
            height: this._container.clientHeight,
          };

          this._camera.canvas = canvas;
          this._camera.fitBox(2, 1);

          this._renderer.setSize(this._container.clientWidth, this._container.clientHeight);

          // update info to draw borders properly
          this._stackHelper.slice.canvasWidth = this._container.clientWidth;
          this._stackHelper.slice.canvasHeight = this._container.clientHeight;
        }
      }

      _orientationChanged(orientation) {
        if (orientation === undefined ||
        orientation === '') {
          return;
        }

        if (this._stackHelper &&
        this._stackHelper.stack) {
          this._camera.orientation = orientation;
          this._camera.update();
          this._camera.fitBox(2, 1);

          //
          this.updateLabels(this._camera.directionsLabel, this._stackHelper.stack.modality);
        }
      }

      updateLabels(labels, modality) {
        if (modality === 'CR' || modality === 'DX') return;

        this.$.top.innerHTML = labels[0];
        this.$.bottom.innerHTML = labels[1];
        this.$.right.innerHTML = labels[2];
        this.$.left.innerHTML = labels[3];
        }
    }
    window.customElements.define(AMIViewer2D.is, AMIViewer2D);
  </script>
</dom-module>